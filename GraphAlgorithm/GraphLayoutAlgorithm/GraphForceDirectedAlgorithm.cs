using GraphBaseFramewark;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace GraphLayoutAlgorithm
{
	public class GraphForceDirectedAlgorithm
	{
		double CANVAS_WIDTH = 200;
		double CANVAS_HEIGHT = 200;
		private List<ShapeCircle> mNodeList;
		private List<ShapeRelationshipLine> mEdgeList;
		private Dictionary<ShapeCircle, double> mDxMap = new Dictionary<ShapeCircle, double>();
		private Dictionary<ShapeCircle, double> mDyMap = new Dictionary<ShapeCircle, double>();
		private Dictionary<ShapeCircle, ShapeCircle> mNodeMap = new Dictionary<ShapeCircle, ShapeCircle>();
		private double k;


		public GraphForceDirectedAlgorithm(List<ShapeCircle> nodeList, List<ShapeRelationshipLine> edgeList,double canvas_width,double canvas_height)
		{
			this.mNodeList = nodeList;
			this.mEdgeList = edgeList;
			this.CANVAS_WIDTH = canvas_width;
			this.CANVAS_HEIGHT = canvas_height;
			if (nodeList != null && nodeList.Count != 0)
			{
				k = Math.Sqrt(CANVAS_WIDTH * CANVAS_HEIGHT / (double)mNodeList.Count);
			}
			if (nodeList != null)
			{
				for (int i = 0; i < nodeList.Count; i++)
				{
					ShapeCircle node = nodeList[i];
					if (node != null)
					{
						mNodeMap.Add(node, node);
					}
				}
			}
		}

		public void Collide()
		{
			CalculateRepulsive();
			CalculateTraction();
			UpdateCoordinates();
		}

		/// <summary>
		/// 计算两个Node的斥力产生的单位位移。
		/// </summary>
		private void CalculateRepulsive()
		{
			double distX, distY, dist;
			for (int v = 0; v < mNodeList.Count; v++)
			{
				ShapeCircle pStartShapeCircle = mNodeList[v];
				mDxMap.Put(pStartShapeCircle, 0.0);
				mDyMap.Put(pStartShapeCircle, 0.0);
				for (int u = 0; u < mNodeList.Count; u++)
				{
					if (u != v)
					{
						ShapeCircle pEndShapeCircle = mNodeList[u];
						distX = pStartShapeCircle.CenterX - pEndShapeCircle.CenterX;
						distY = pStartShapeCircle.CenterY - pEndShapeCircle.CenterY;
						dist = Math.Sqrt(distX * distX + distY * distY);

						if (dist >= 0 && dist <= 200)
						{
							mDxMap.Put(pStartShapeCircle, mDxMap[pStartShapeCircle] + (distX / dist * k * k / dist ));
							mDyMap.Put(pStartShapeCircle, mDyMap[pStartShapeCircle] + (distY / dist * k * k / dist ));
						}
					}
				}
			}
		}

		/// <summary>
		/// 计算Edge的引力对两端Node产生的引力。
		/// Calculate the traction force generated by the edge acted on the two nodes of its two ends.
		/// </summary>
		private void CalculateTraction()
		{
			int condenseFactor = 3;
			ShapeCircle startNode, endNode;
			for (int e = 0; e < mEdgeList.Count; e++)
			{
				ShapeCircle eStartID = mEdgeList[e].StartShapeCircle;
				ShapeCircle eEndID = mEdgeList[e].EndShapeCircle;
				startNode = mNodeMap[eStartID];
				endNode = mNodeMap[eEndID];
				if (startNode == null)
				{
					Console.WriteLine("Cannot find node id: " + eStartID + ", please check it out.");
					return;
				}
				if (endNode == null)
				{
					Console.WriteLine("Cannot find node id: " + eEndID + ", please check it out.");
					return;
				}
				double distX, distY, dist;
				distX = startNode.CenterX - endNode.CenterX;
				distY = startNode.CenterY - endNode.CenterY;
				dist = Math.Sqrt(distX * distX + distY * distY);

				mDxMap.Put(eStartID, mDxMap[eStartID] - (distX * dist * dist / k));
				mDyMap.Put(eStartID, mDyMap[eStartID] - (distY * dist * dist / k));

				mDxMap.Put(eEndID, mDxMap[eEndID] + (distX * dist * dist / k));
				mDyMap.Put(eEndID, mDyMap[eEndID] + (distY * dist * dist / k));
			}
		}


		/// <summary>
		/// 更新坐标。
		/// update the coordinates.
		/// </summary>
		private void UpdateCoordinates()
		{
			int maxt = 4, maxty = 3; //Additional coefficients.
			for (int v = 0; v < mNodeList.Count; v++)
			{
				ShapeCircle node = mNodeList[v];
				int dx = (int)Math.Floor(mDxMap[node]);
				int dy = (int)Math.Floor(mDyMap[node]);

				if (dx < -maxt) dx = -maxt;
				if (dx > maxt) dx = maxt;
				if (dy < -maxty) dy = -maxty;
				if (dy > maxty) dy = maxty;

				double PointCenterX = Math.Min(node.CenterX, CANVAS_WIDTH);
				double PointCenterY = Math.Min(node.CenterY, CANVAS_HEIGHT);

				PointCenterX = Math.Max(PointCenterX, 0);
				PointCenterY = Math.Max(PointCenterY, 0);

				node.CenterX = ((PointCenterX + dx) >= CANVAS_WIDTH || (PointCenterX + dx) <= 0 ? PointCenterX - dx : PointCenterX + dx);
				node.CenterY = ((PointCenterY + dy) >= CANVAS_HEIGHT || (PointCenterY + dy <= 0) ? PointCenterY - dy : PointCenterY + dy);
			}
		}

		List<ShapeCircle> getNodeList()
		{
			return mNodeList == null ? new List<ShapeCircle>() : mNodeList;
		}
	}
}